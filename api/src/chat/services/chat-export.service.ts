import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../shared/prisma/prisma.service';
import PDFDocument from 'pdfkit';
import { Readable } from 'stream';

/**
 * Chat Export Service
 * 
 * Export chat messages to PDF or TXT format for PIPEDA compliance.
 * Users have the right to export their data in a portable format.
 * 
 * Formats:
 * - PDF: Professional formatted document with header and timestamps
 * - TXT: Plain text format for easy reading
 */
@Injectable()
export class ChatExportService {
  private readonly logger = new Logger(ChatExportService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Export chat to PDF format
   * 
   * @param orderId - Order ID
   * @param userId - User requesting export (must be participant)
   * @returns PDF buffer
   */
  async exportToPdf(orderId: string, userId: string): Promise<Buffer> {
    // Verify user is participant and get order details
    const order = await this.verifyAccess(orderId, userId);

    // Fetch all messages
    const messages = await this.prisma.message.findMany({
      where: { orderId },
      orderBy: { createdAt: 'asc' },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (messages.length === 0) {
      throw new NotFoundException('No messages found for this order');
    }

    // Create PDF document
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 50, bottom: 50, left: 50, right: 50 },
    });

    // Collect PDF chunks
    const chunks: Buffer[] = [];
    doc.on('data', (chunk: Buffer) => chunks.push(chunk));

    // Header
    doc
      .fontSize(20)
      .font('Helvetica-Bold')
      .text('Chat Export - Hummii Platform', { align: 'center' });
    
    doc.moveDown();
    
    // Order information
    doc.fontSize(12).font('Helvetica');
    doc.text(`Order: ${order.title || 'Untitled'}`, { continued: false });
    doc.text(`Order ID: #${order.id.slice(0, 8).toUpperCase()}`, { continued: false });
    doc.text(`Export Date: ${new Date().toLocaleString('en-CA')}`, { continued: false });
    
    // Participants
    doc.moveDown();
    doc.fontSize(11).font('Helvetica-Bold');
    doc.text('Participants:', { continued: false });
    doc.fontSize(10).font('Helvetica');
    doc.text(`- ${order.client.name} (Client)`, { continued: false });
    doc.text(`- ${order.contractor?.name || 'N/A'} (Contractor)`, { continued: false });
    
    doc.moveDown();
    doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
    doc.moveDown();

    // Messages
    doc.fontSize(11).font('Helvetica-Bold');
    doc.text('Messages:', { continued: false });
    doc.moveDown(0.5);

    for (const message of messages) {
      // Check for new page
      if (doc.y > 700) {
        doc.addPage();
      }

      // Timestamp and sender
      const timestamp = message.createdAt.toLocaleString('en-CA', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      });

      doc.fontSize(9).font('Helvetica-Bold');
      doc.text(`[${timestamp}] ${message.sender.name}:`, {
        continued: false,
      });

      // Message content
      doc.fontSize(9).font('Helvetica');
      doc.text(message.content, {
        continued: false,
        indent: 10,
      });

      // Edited indicator
      if (message.isEdited) {
        doc.fontSize(8).font('Helvetica-Oblique').fillColor('gray');
        doc.text('(edited)', { indent: 10, continued: false });
        doc.fillColor('black');
      }

      // Moderated indicator
      if (message.isModerated) {
        doc.fontSize(8).font('Helvetica-Oblique').fillColor('red');
        doc.text('(moderated - inappropriate content removed)', {
          indent: 10,
          continued: false,
        });
        doc.fillColor('black');
      }

      doc.moveDown(0.5);
    }

    // Footer
    doc.moveDown();
    doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
    doc.moveDown(0.5);
    doc.fontSize(8).font('Helvetica-Oblique').fillColor('gray');
    doc.text(
      `This export contains ${messages.length} message(s). Generated by Hummii Platform.`,
      { align: 'center' },
    );

    // Finalize PDF
    doc.end();

    // Wait for PDF generation to complete
    await new Promise<void>((resolve, reject) => {
      doc.on('end', () => resolve());
      doc.on('error', (error: Error) => reject(error));
    });

    const pdfBuffer = Buffer.concat(chunks);
    
    this.logger.log(`Exported ${messages.length} messages to PDF for order ${orderId}`);

    return pdfBuffer;
  }

  /**
   * Export chat to TXT format
   * 
   * @param orderId - Order ID
   * @param userId - User requesting export (must be participant)
   * @returns TXT content as string
   */
  async exportToTxt(orderId: string, userId: string): Promise<string> {
    // Verify user is participant and get order details
    const order = await this.verifyAccess(orderId, userId);

    // Fetch all messages
    const messages = await this.prisma.message.findMany({
      where: { orderId },
      orderBy: { createdAt: 'asc' },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (messages.length === 0) {
      throw new NotFoundException('No messages found for this order');
    }

    // Build TXT content
    let txtContent = '';

    // Header
    txtContent += '='.repeat(80) + '\n';
    txtContent += 'Chat Export - Hummii Platform\n';
    txtContent += '='.repeat(80) + '\n\n';

    // Order information
    txtContent += `Order: ${order.title || 'Untitled'}\n`;
    txtContent += `Order ID: #${order.id.slice(0, 8).toUpperCase()}\n`;
    txtContent += `Export Date: ${new Date().toLocaleString('en-CA')}\n\n`;

    // Participants
    txtContent += 'Participants:\n';
    txtContent += `- ${order.client.name} (Client)\n`;
    txtContent += `- ${order.contractor?.name || 'N/A'} (Contractor)\n\n`;
    txtContent += '-'.repeat(80) + '\n\n';

    // Messages
    for (const message of messages) {
      const timestamp = message.createdAt.toLocaleString('en-CA', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      });

      txtContent += `[${timestamp}] ${message.sender.name}:\n`;
      txtContent += `${message.content}\n`;

      if (message.isEdited) {
        txtContent += '(edited)\n';
      }

      if (message.isModerated) {
        txtContent += '(moderated - inappropriate content removed)\n';
      }

      txtContent += '\n';
    }

    // Footer
    txtContent += '-'.repeat(80) + '\n';
    txtContent += `This export contains ${messages.length} message(s).\n`;
    txtContent += `Generated by Hummii Platform.\n`;

    this.logger.log(`Exported ${messages.length} messages to TXT for order ${orderId}`);

    return txtContent;
  }

  /**
   * Verify user access to order chat
   * 
   * @param orderId - Order ID
   * @param userId - User ID
   * @returns Order details
   */
  private async verifyAccess(orderId: string, userId: string) {
    const order = await this.prisma.order.findUnique({
      where: { id: orderId },
      select: {
        id: true,
        title: true,
        clientId: true,
        contractorId: true,
        client: {
          select: {
            id: true,
            name: true,
          },
        },
        contractor: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!order) {
      throw new NotFoundException('Order not found');
    }

    const isParticipant = order.clientId === userId || order.contractorId === userId;
    if (!isParticipant) {
      throw new NotFoundException('You are not a participant of this order');
    }

    return order;
  }
}

