---
alwaysApply: true
---
You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Aim for less than 20-30 lines.
  - Complex business logic (payments, disputes) may justify longer functions.
  - Prioritize readability over strict line limits.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Aim for less than 200-300 lines.
  - Less than 10-15 public methods.
  - Less than 10 properties.
  - Complex services (e.g., payment processing, dispute resolution) may exceed these limits if justified.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
  - A services module with business logic and persistence.
    - Entities with Prisma or TypeORM for data persistence.
    - One service per entity.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.
  - Utilities
  - Shared business logic

### Security

- Use @nestjs/throttler for rate limiting
  - Global: 100 req/min per IP
  - Auth endpoints: 5 req/min (login, password reset)
  - Registration endpoint: 3 req/hour (stricter to prevent spam/bot accounts)
  - Chat/messaging: 20 messages/min per user
- Validate all inputs with DTOs
  - Set whitelist: true (strip unknown properties)
  - Set forbidNonWhitelisted: true (throw error on unknown properties)
  - Set transform: true for automatic type conversion
- Use Helmet.js for security headers
  - Content Security Policy (CSP)
  - X-Frame-Options: DENY
  - X-Content-Type-Options: nosniff
- Enable CORS with whitelist only (never use wildcard in production)
- Password security
  - Use bcrypt or Argon2 for password hashing
  - Use cost factor 12+ for bcrypt
  - Never store passwords in plain text
  - Implement password complexity requirements:
    - Minimum 12 characters
    - At least one uppercase letter (A-Z)
    - At least one lowercase letter (a-z)
    - At least one number (0-9)
    - At least one special character (@$!%*?&)
    - No common passwords or patterns
    - Validate on both client (Zod) and server (class-validator)
- JWT tokens
  - Use short-lived access tokens (15 minutes)
  - Use HTTP-only cookies for refresh tokens (7 days)
  - Implement token rotation on refresh
  - Store refresh tokens in database for revocation
- Store secrets in environment variables
  - Never hardcode API keys, passwords, or secrets
  - Use .env files with proper .gitignore
  - Consider using AWS Secrets Manager or HashiCorp Vault for production
- Implement CSRF protection for state-changing operations
- Use parameterized queries (ORM handles this automatically)
- Sanitize user inputs to prevent XSS attacks
- Implement file upload validation
  - Check file MIME types (whitelist only)
  - Limit file sizes (e.g., 5MB per image)
  - Scan for viruses (use ClamAV or cloud service)
  - Strip EXIF metadata from images

### Data & Privacy (PIPEDA Compliance - Canada)

- Implement data minimization
  - Collect only necessary data
  - Clearly document purpose for each data field
  - Mark optional fields explicitly
- Mask PII (Personal Identifiable Information) in logs
  - Never log passwords, tokens, credit cards, SIN numbers
  - Mask email addresses (u***@example.com)
  - Mask phone numbers (***-***-1234)
  - Use correlation IDs instead of user IDs in logs
- Implement user rights endpoints (PIPEDA compliance)
  - Right to Access - export all user data (GET /users/me/export, JSON/PDF format)
  - Right to Rectification - allow profile editing (PATCH /users/me)
  - Right to Erasure - full account deletion with data anonymization (DELETE /users/me)
  - Right to Data Portability - machine-readable data export (GET /users/me/export)
  - Right to Object - opt-out of marketing emails (PATCH /users/me/consent)
  - Right to Withdraw Consent - clear consent management (PATCH /users/me/consent)
- Use encryption
  - Encryption at rest for database (PostgreSQL TDE)
  - Encryption in transit (TLS 1.3, HTTPS only)
  - Field-level encryption for sensitive data (credit cards, SIN)
- Implement data retention policies
  - Define retention periods for each data type
  - Automatically delete expired data via scheduled cron jobs
  - Keep audit logs for 1 year minimum (PIPEDA requirement for security/compliance)
  - Keep chat messages for 90 days (then auto-delete)
  - Keep payment records for 7 years (Canadian tax law - CRA requirement)
  - Keep session data for 7 days (refresh token lifetime)
  - Implement automated cleanup jobs using @nestjs/schedule (daily cleanup tasks)
- Implement audit logging
  - Log all data access and modifications
  - Log authentication attempts (success and failures)
  - Log admin actions
  - Never log sensitive data in audit trails
- Prepare for data breach response
  - Document incident response plan
  - Notify affected users within 72 hours
  - Notify Privacy Commissioner of Canada if serious
- Provide clear privacy documentation
  - Privacy Policy (English + French)
  - Terms of Service
  - Cookie consent management
  - List of third-party data processors

### API Documentation

- Use Swagger/OpenAPI decorators
  - @ApiTags() for controller grouping
  - @ApiOperation() for endpoint descriptions
  - @ApiResponse() for response documentation
  - @ApiParam() for path parameters
  - @ApiQuery() for query parameters
  - @ApiBearerAuth() for protected endpoints
- Document all DTOs with @ApiProperty()
  - Include type, description, example
  - Mark required vs optional fields
  - Document validation rules
- Generate OpenAPI spec automatically
- Version your API (e.g., /api/v1/)
- Document breaking changes in changelog

### Logging & Monitoring

- Use structured logging (Winston or Pino)
  - Use log levels appropriately (error, warn, info, debug)
  - Include correlation IDs for request tracking
  - Include user ID (not PII) for action tracking
  - Include timestamp in ISO 8601 format
- Implement log aggregation
  - Centralize logs for analysis
  - Use ELK stack or cloud service
  - Set up alerts for critical errors
- Never log sensitive data
  - Passwords, tokens, API keys
  - Credit card numbers
  - Personal identifiable information (PII)
  - Use masking utilities for necessary PII in logs
- Integrate error tracking (Sentry or similar)
  - Capture unhandled exceptions
  - Add context to errors (user, request, environment)
  - Set up alerts for critical errors
  - Track error trends and patterns
- Monitor performance
  - Track response times
  - Monitor database query performance
  - Set up alerts for slow endpoints
  - Use APM tools (New Relic, DataDog)

### Real-time Communication

- Use @nestjs/websockets with Socket.io
  - Create WebSocketGateway for real-time features
  - Use rooms for private chats
  - Implement proper namespaces for separation
- Implement WebSocket authentication
  - Use guards for WebSocket connections
  - Verify JWT tokens on connection
  - Handle token expiration gracefully
- Handle disconnections properly
  - Implement reconnection logic
  - Clean up resources on disconnect
  - Update user online status
- Emit typed events with DTOs
  - Define event interfaces
  - Validate event payloads
  - Document event types
- Implement rate limiting for WebSocket events
  - Prevent spam and abuse
  - Disconnect abusive clients
  - Log suspicious activity

### Background Jobs & Scheduling

- Use Bull/BullMQ for queue management
  - Create separate queues for different job types
  - Set appropriate concurrency limits
  - Implement job prioritization
- Use @nestjs/schedule for cron jobs
  - Document cron schedules clearly
  - Use timezone-aware scheduling
  - Implement idempotency for cron jobs
  - Required PIPEDA compliance jobs:
    - Daily cleanup: chat messages (>90 days), expired sessions, old notifications
    - Weekly cleanup: audit logs (>1 year, but keep minimum 1 year)
    - Never auto-delete payment records (7 years retention, manual only)
- Handle job failures with retry logic
  - Set maximum retry attempts
  - Use exponential backoff
  - Move to dead letter queue after max retries
  - Alert on repeated failures
- Log job execution
  - Log start and completion times
  - Log job results and errors
  - Track job performance metrics
- Common job types
  - Email notifications (async)
  - Push notifications (async)
  - Data cleanup (scheduled) - PIPEDA compliance:
    - Daily: cleanup old chat messages (>90 days)
    - Daily: cleanup expired sessions
    - Weekly: cleanup old audit logs (>1 year, keep minimum 1 year)
    - Weekly: cleanup unread notifications (>90 days, keep read ones)
  - Report generation (scheduled)
  - Webhook retries (async with backoff)

### Content Moderation

- Implement automatic moderation for user-generated content
  - Block phone numbers in chat messages (regex patterns)
  - Block email addresses in chat messages
  - Block external links (except platform URLs)
  - Block social media handles (@instagram, @telegram, @whatsapp)
  - Filter profanity (Canadian English + French)
- Create moderation service with clear patterns
  - Use configurable regex patterns
  - Return moderation flags (phone, email, link, social)
  - Replace blocked content with *** or [removed]
  - Log moderation events for analytics
- Implement rate limiting for content creation
  - Limit messages per minute (20 per user)
  - Limit orders creation (10 per hour)
  - Limit profile updates (5 per hour)
- Create report/flag system
  - Allow users to report inappropriate content
  - Auto-suspend after threshold (e.g., 3 reports)
  - Queue for admin review
  - Track repeat offenders
- Moderate file uploads
  - AI-based NSFW detection for images
  - Manual review queue for suspicious content
  - Automatic approval for verified users
  - Track moderation decisions for appeals

### AI Content Moderation

- Use AWS Rekognition for NSFW/inappropriate image detection
  - Detect explicit nudity, suggestive content, violence
  - Detect offensive symbols, drugs, alcohol
  - Label confidence scoring (0-100%)
- Implement moderation thresholds
  - Confidence > 90% = auto-block, notify user
  - Confidence 70-90% = hold for manual review
  - Confidence < 70% = auto-approve
- Create manual review queue
  - Admin panel for reviewing flagged content
  - Approve/reject with reason
  - Track moderator decisions for quality assurance
  - Appeal system for false positives
- Implement progressive penalties
  - 1st violation = warning
  - 2nd violation = 7-day suspension
  - 3rd violation = permanent ban
- Store moderation decisions
  - Keep audit trail for appeals
  - Track false positive rate
  - Improve AI model over time
- Alternative: Google Cloud Vision API or Azure Content Moderator
  - Same threshold logic applies
  - Choose based on cost and accuracy

### Guards & Decorators Examples

**Subscription Guard:**
```typescript
// Protect endpoints based on subscription tier
import { Injectable, CanActivate, ExecutionContext, PaymentRequiredException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { SubscriptionTier } from '@prisma/client';

@Injectable()
export class SubscriptionGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private subscriptionService: SubscriptionService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredTier = this.reflector.get<SubscriptionTier>(
      'subscriptionTier',
      context.getHandler(),
    );

    if (!requiredTier) {
      return true; // No tier required
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    const subscription = await this.subscriptionService.getUserSubscription(user.id);

    if (!subscription || !this.hasRequiredTier(subscription.tier, requiredTier)) {
      throw new PaymentRequiredException('Upgrade your subscription to access this feature');
    }

    return true;
  }

  private hasRequiredTier(userTier: SubscriptionTier, requiredTier: SubscriptionTier): boolean {
    const tierOrder = {
      [SubscriptionTier.BASIC]: 0,
      [SubscriptionTier.STANDARD]: 1,
      [SubscriptionTier.PROFESSIONAL]: 2,
      [SubscriptionTier.ADVANCED]: 3,
    };

    return tierOrder[userTier] >= tierOrder[requiredTier];
  }
}

// Usage:
@Post('categories')
@UseGuards(JwtAuthGuard, SubscriptionGuard)
@SubscriptionTier(SubscriptionTier.PROFESSIONAL)
async addCategory(@User() user: UserEntity, @Body() dto: AddCategoryDto) {
  // Only Professional and Advanced tiers can access
}
```

**Verification Guard:**
```typescript
// Require verified users for certain actions
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';

@Injectable()
export class VerificationGuard implements CanActivate {
  constructor(private verificationService: VerificationService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    const isVerified = await this.verificationService.isUserVerified(user.id);

    if (!isVerified) {
      throw new ForbiddenException(
        'You must verify your identity to perform this action. Please complete verification in your profile settings.',
      );
    }

    return true;
  }
}

// Usage:
@Post('orders/:id/accept')
@UseGuards(JwtAuthGuard, VerificationGuard)
async acceptOrder(@Param('id') orderId: string) {
  // Only verified users can accept orders
}
```

**Role Guard (RBAC):**
```typescript
// Protect admin-only endpoints
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '@prisma/client';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.get<UserRole[]>('roles', context.getHandler());

    if (!requiredRoles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    const hasRole = user.roles.some((role) => requiredRoles.includes(role));

    if (!hasRole) {
      throw new ForbiddenException('You do not have permission to access this resource');
    }

    return true;
  }
}

// Decorator:
export const Roles = (...roles: UserRole[]) => SetMetadata('roles', roles);

// Usage:
@Get('admin/users')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
async getAllUsers() {
  // Only admins can access
}
```

### Backend i18n (Internationalization)

- Use nestjs-i18n for API error messages and notifications
  - Install: `npm install nestjs-i18n`
  - Configure for English (EN) and French (FR)
- Store translations in `/api/src/i18n/[locale]/`
  - `en/errors.json` - English error messages
  - `fr/errors.json` - French error messages
  - `en/notifications.json` - English notification templates
  - `fr/notifications.json` - French notification templates
- Pass Accept-Language header from frontend
  - Frontend sets header based on user preference
  - Default to English if locale not supported
- Implement i18n in services and controllers

**Configuration:**
```typescript
// app.module.ts
import { I18nModule, AcceptLanguageResolver, QueryResolver, HeaderResolver } from 'nestjs-i18n';
import * as path from 'path';

@Module({
  imports: [
    I18nModule.forRoot({
      fallbackLanguage: 'en',
      loaderOptions: {
        path: path.join(__dirname, '/i18n/'),
        watch: true,
      },
      resolvers: [
        { use: QueryResolver, options: ['lang'] }, // ?lang=fr
        AcceptLanguageResolver, // Accept-Language header
        new HeaderResolver(['x-custom-lang']), // Custom header
      ],
    }),
  ],
})
export class AppModule {}
```

**Translation Files:**
```json
// src/i18n/en/errors.json
{
  "INVALID_EMAIL": "Invalid email address",
  "INVALID_PASSWORD": "Password must be at least 12 characters with uppercase, lowercase, number, and special character",
  "USER_NOT_FOUND": "User not found",
  "ORDER_NOT_FOUND": "Order not found",
  "PAYMENT_FAILED": "Payment failed. Please try again.",
  "INSUFFICIENT_PERMISSIONS": "You do not have permission to perform this action"
}

// src/i18n/fr/errors.json
{
  "INVALID_EMAIL": "Adresse e-mail invalide",
  "INVALID_PASSWORD": "Le mot de passe doit comporter au moins 12 caractères avec des majuscules, des minuscules, des chiffres et des caractères spéciaux",
  "USER_NOT_FOUND": "Utilisateur introuvable",
  "ORDER_NOT_FOUND": "Commande introuvable",
  "PAYMENT_FAILED": "Le paiement a échoué. Veuillez réessayer.",
  "INSUFFICIENT_PERMISSIONS": "Vous n'avez pas la permission d'effectuer cette action"
}
```

**Usage in Services:**
```typescript
import { Injectable } from '@nestjs/common';
import { I18nService } from 'nestjs-i18n';

@Injectable()
export class UsersService {
  constructor(private readonly i18n: I18nService) {}

  async findByEmail(email: string, lang: string = 'en') {
    const user = await this.prisma.user.findUnique({ where: { email } });

    if (!user) {
      throw new NotFoundException(
        this.i18n.t('errors.USER_NOT_FOUND', { lang }),
      );
    }

    return user;
  }
}
```

**Usage in Controllers:**
```typescript
import { Controller, Get, BadRequestException } from '@nestjs/common';
import { I18n, I18nContext } from 'nestjs-i18n';

@Controller('users')
export class UsersController {
  @Get()
  async getUsers(@I18n() i18n: I18nContext) {
    // Automatically gets language from request
    throw new BadRequestException(
      i18n.t('errors.INVALID_EMAIL'),
    );
  }
}
```

**Email Templates:**
```typescript
// Use i18n for email subject and body
async sendWelcomeEmail(user: User, lang: string) {
  const subject = this.i18n.t('emails.WELCOME_SUBJECT', { lang, args: { name: user.firstName } });
  const body = this.i18n.t('emails.WELCOME_BODY', { lang, args: { name: user.firstName } });

  await this.emailService.send({
    to: user.email,
    subject,
    body,
  });
}
```

### Payment Integration (Stripe)

- Never store credit card information
  - Use Stripe.js for card tokenization
  - Store only Stripe customer/payment method IDs
  - Comply with PCI DSS via Stripe
- Verify webhook signatures
  - Always verify Stripe webhook signatures
  - Use raw body for signature verification
  - Handle webhook events idempotently
  - Log all webhook events for debugging
- Use idempotency keys
  - Generate unique keys for payment operations
  - Prevent duplicate charges
  - Store keys with transaction records
- Implement 3D Secure (SCA)
  - Use PaymentIntents API
  - Handle authentication requirements
  - Provide clear user flow for verification
- Handle refunds properly
  - Implement refund policies
  - Track refund reasons
  - Update order status after refunds
  - Notify users of refund status
- Use Stripe metadata
  - Store order ID in Stripe metadata
  - Store user ID for tracking
  - Include platform-specific data
- Implement proper error handling
  - Handle card declined errors gracefully
  - Show user-friendly error messages
  - Log errors for debugging
  - Implement retry logic where appropriate

### Identity Verification (Stripe Identity)

- Use Stripe Identity API for document verification
- Support Canadian documents
  - Driver's License
  - Passport
  - Provincial ID Card
- Implement verification flow
  - Create VerificationSession via Stripe API
  - Return session URL to frontend for redirect
  - Handle webhook verification.session.completed
  - Update user verification status in database
  - Grant "Verified" badge on profile
- Store only verification status and session ID
  - Never store document images locally
  - Comply with privacy laws (minimal data retention)
- Implement verification check guard
  - Protect certain features (require verification)
  - Check verification status before allowing actions
- Set verification expiration (e.g., 2 years)
  - Send reminder to re-verify before expiration
  - Implement automated re-verification flow

### Dispute Resolution Module

- Implement dispute lifecycle with clear statuses
  - OPENED - dispute initiated by user
  - UNDER_REVIEW - admin investigating evidence
  - AWAITING_RESPONSE - waiting for party response
  - RESOLVED - decision made by admin
  - CLOSED - case closed and archived
- Create dispute evidence system
  - Allow photo/screenshot uploads (max 5 files, 5MB each)
  - Link to related chat messages
  - Attach order details automatically
  - Store dispute description (max 2000 chars)
- Freeze payments during active disputes
  - Hold funds in escrow until resolution
  - Prevent withdrawal or transfer
  - Notify both parties of freeze
- Implement decision types
  - FULL_REFUND - 100% refund to client
  - FULL_PAYMENT - 100% payment to contractor
  - PARTIAL - custom split (e.g., 60/40)
  - BLOCK_USER - ban violator and refund
- Set Service Level Agreement (SLA)
  - Resolve disputes within 3-5 business days
  - Auto-escalate if exceeding SLA
  - Send daily updates to involved parties
- Track dispute history
  - Count disputes per user (flag repeat offenders)
  - Display dispute count in admin panel
  - Impact rating if disputes exceed threshold (e.g., 3+)
- Implement admin dashboard
  - Queue of pending disputes
  - Filter by status, date, severity
  - Bulk actions for common decisions
  - Audit log of admin decisions

### Notification System (OneSignal)

- Implement multi-channel delivery strategy
  - In-App (Socket.io) - real-time for online users
  - Email (OneSignal) - for offline or high priority
  - Push (OneSignal) - if enabled in user settings
- Define notification priority levels
  - HIGH PRIORITY (always send immediately)
    - New response to your order
    - Payment received/completed
    - Dispute opened
    - Security alerts (password change, new login)
  - MEDIUM PRIORITY (send based on preferences)
    - New message in chat
    - Order status changed
    - New review received
    - New order in your category
  - LOW PRIORITY (batch in daily/weekly digest)
    - Profile view count
    - Weekly summary
    - Subscription reminder (7 days before expiration)
- Implement user notification preferences
  - Per-channel toggles (email on/off, push on/off)
  - Frequency settings (instant, daily digest, never)
  - Category filters (orders, messages, reviews, system)
- Store notification history in database
  - id, user_id, type, title, message, priority, read_status, created_at
  - Mark as read/unread
  - Auto-delete after 90 days (keep only unread)
- Implement notification batching
  - Batch low-priority notifications
  - Send daily digest at user's preferred time
  - Group similar notifications (e.g., "5 new profile views")
- Rate limit notifications
  - Max 50 notifications per day per user
  - Prevent spam from system or users
  - Log excessive notification attempts
- Create notification templates
  - Use i18n for English/French support
  - Personalize with user name and details
  - Include clear call-to-action links

### Subscription Management (Stripe Subscriptions)

- Define subscription tiers for contractors
  - Basic (Free): Limited features, max 3 categories
  - Standard ($X/month): 5 categories, 5% partner discounts
  - Professional ($Y/month): Unlimited categories, 10% discounts, priority listing
  - Advanced ($Z/month): All features, 15% discounts, featured profile, no platform fee
- Integrate Stripe Subscriptions API
  - Create subscription products and prices in Stripe
  - Use recurring billing (monthly/yearly options)
  - Implement subscription creation endpoint
  - Handle payment method updates
- Handle subscription lifecycle via webhooks
  - customer.subscription.created - activate features
  - customer.subscription.updated - update tier
  - customer.subscription.deleted - downgrade to free
  - invoice.payment_succeeded - extend subscription
  - invoice.payment_failed - notify user, retry payment
  - invoice.payment_action_required - 3D Secure needed
- Implement feature gating based on subscription
  - Check subscription tier before allowing actions
  - Create @SubscriptionGuard decorator
  - Return 402 Payment Required for locked features
- Allow upgrade/downgrade mid-cycle
  - Prorate billing when changing plans
  - Immediate feature access on upgrade
  - Grace period on downgrade (end of billing period)
- Send subscription reminders
  - 7 days before expiration
  - 3 days before expiration
  - 1 day before expiration
  - Day of expiration (with renewal link)
- Implement subscription analytics
  - Track MRR (Monthly Recurring Revenue)
  - Churn rate calculation
  - Conversion rate (free to paid)
  - Popular plan analysis

### Partner Portal Integration

- Implement QR code generation for contractors
  - Generate time-limited QR codes (valid for 15 minutes)
  - Include contractor ID, subscription tier, timestamp
  - Sign QR data with secret key to prevent forgery
  - Return QR as base64 image or data URL
- Verify contractor subscription before QR generation
  - Check active subscription status
  - Verify subscription tier (Standard/Professional/Advanced)
  - Return error if subscription expired or free tier
- Create QR validation endpoint for partners
  - Accept QR data from partner scanner
  - Verify signature and expiration
  - Check contractor subscription status
  - Return discount percentage based on tier
    - Standard → 5%
    - Professional → 10%
    - Advanced → 15%
- Track discount usage for analytics
  - Store transaction: contractor_id, partner_id, discount_amount, date
  - Calculate total savings per contractor
  - Generate monthly reports for contractors
  - Track partner participation metrics
- Implement partner management
  - Partner registration and profile
  - Partner location and business details
  - Discount configuration per subscription tier
  - Active/inactive status toggle
- Create partner dashboard endpoints
  - Recent scans and validations
  - Transaction history
  - Statistics (daily/weekly/monthly scans)
  - Top contractors by usage

### Category Management

- Implement hierarchical category structure
  - Use adjacency list or nested set model
  - Support parent-child relationships (category → subcategory)
  - Example: "Repair" → "Electrical", "Plumbing", "Carpentry"
- Define category schema
  - id, parent_id, name_en, name_fr, slug, icon, description, order, is_active
  - Support internationalization (English/French)
  - Include icon identifier for UI display
- Limit contractor category selection
  - Max 5 categories per contractor (3 for free tier)
  - Validate category IDs on selection
  - Allow category change (max once per month)
- Implement category-based features
  - Search and filter orders by category
  - Send notifications for new orders in contractor's categories
  - Display category badges on profiles
  - Track popular categories for analytics
- Create category management endpoints
  - CRUD operations (admin only)
  - Bulk category assignment
  - Category tree retrieval (with nesting)
  - Category search with autocomplete
- Make categories easily configurable
  - Admin panel integration for category editing
  - Drag-and-drop ordering support
  - Bulk enable/disable categories
  - Category usage statistics (how many contractors per category)

### Testing

- Use the standard Jest framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.
- Test critical business logic thoroughly
  - Payment flows (success, failure, refund)
  - Dispute resolution logic
  - Subscription upgrades/downgrades
  - Notification delivery logic
  - QR code generation and validation
- Mock external services in tests
  - Stripe API calls
  - OneSignal API calls
  - Socket.io events
  - Google Maps API
- Test security features
  - Authentication and authorization
  - Rate limiting behavior
  - Input validation and sanitization
  - CSRF protection
 