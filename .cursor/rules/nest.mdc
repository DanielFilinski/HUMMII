---
alwaysApply: false
---


You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Aim for less than 20-30 lines.
  - Complex business logic (payments, disputes) may justify longer functions.
  - Prioritize readability over strict line limits.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Aim for less than 200-300 lines.
  - Less than 10-15 public methods.
  - Less than 10 properties.
  - Complex services (e.g., payment processing, dispute resolution) may exceed these limits if justified.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
  - A services module with business logic and persistence.
    - Entities with Prisma or TypeORM for data persistence.
    - One service per entity.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.
  - Utilities
  - Shared business logic

### Security

- Use @nestjs/throttler for rate limiting
  - Global: 100 req/min per IP
  - Auth endpoints: 5 req/min (login, register, password reset)
  - Chat/messaging: 20 messages/min per user
- Validate all inputs with DTOs
  - Set whitelist: true (strip unknown properties)
  - Set forbidNonWhitelisted: true (throw error on unknown properties)
  - Set transform: true for automatic type conversion
- Use Helmet.js for security headers
  - Content Security Policy (CSP)
  - X-Frame-Options: DENY
  - X-Content-Type-Options: nosniff
- Enable CORS with whitelist only (never use wildcard in production)
- Password security
  - Use bcrypt or Argon2 for password hashing
  - Use cost factor 12+ for bcrypt
  - Never store passwords in plain text
  - Implement password complexity requirements
- JWT tokens
  - Use short-lived access tokens (15 minutes)
  - Use HTTP-only cookies for refresh tokens (7 days)
  - Implement token rotation on refresh
  - Store refresh tokens in database for revocation
- Store secrets in environment variables
  - Never hardcode API keys, passwords, or secrets
  - Use .env files with proper .gitignore
  - Consider using AWS Secrets Manager or HashiCorp Vault for production
- Implement CSRF protection for state-changing operations
- Use parameterized queries (ORM handles this automatically)
- Sanitize user inputs to prevent XSS attacks
- Implement file upload validation
  - Check file MIME types (whitelist only)
  - Limit file sizes (e.g., 5MB per image)
  - Scan for viruses (use ClamAV or cloud service)
  - Strip EXIF metadata from images

### Data & Privacy (PIPEDA Compliance - Canada)

- Implement data minimization
  - Collect only necessary data
  - Clearly document purpose for each data field
  - Mark optional fields explicitly
- Mask PII (Personal Identifiable Information) in logs
  - Never log passwords, tokens, credit cards, SIN numbers
  - Mask email addresses (u***@example.com)
  - Mask phone numbers (***-***-1234)
  - Use correlation IDs instead of user IDs in logs
- Implement user rights endpoints
  - Right to Access - export all user data (JSON/PDF)
  - Right to Rectification - allow profile editing
  - Right to Erasure - full account deletion with data anonymization
  - Right to Data Portability - machine-readable data export
- Use encryption
  - Encryption at rest for database (PostgreSQL TDE)
  - Encryption in transit (TLS 1.3, HTTPS only)
  - Field-level encryption for sensitive data (credit cards, SIN)
- Implement data retention policies
  - Define retention periods for each data type
  - Automatically delete expired data
  - Keep audit logs for 90 days minimum
  - Keep payment records for 7 years (Canadian tax law)
- Implement audit logging
  - Log all data access and modifications
  - Log authentication attempts (success and failures)
  - Log admin actions
  - Never log sensitive data in audit trails
- Prepare for data breach response
  - Document incident response plan
  - Notify affected users within 72 hours
  - Notify Privacy Commissioner of Canada if serious
- Provide clear privacy documentation
  - Privacy Policy (English + French)
  - Terms of Service
  - Cookie consent management
  - List of third-party data processors

### API Documentation

- Use Swagger/OpenAPI decorators
  - @ApiTags() for controller grouping
  - @ApiOperation() for endpoint descriptions
  - @ApiResponse() for response documentation
  - @ApiParam() for path parameters
  - @ApiQuery() for query parameters
  - @ApiBearerAuth() for protected endpoints
- Document all DTOs with @ApiProperty()
  - Include type, description, example
  - Mark required vs optional fields
  - Document validation rules
- Generate OpenAPI spec automatically
- Version your API (e.g., /api/v1/)
- Document breaking changes in changelog

### Logging & Monitoring

- Use structured logging (Winston or Pino)
  - Use log levels appropriately (error, warn, info, debug)
  - Include correlation IDs for request tracking
  - Include user ID (not PII) for action tracking
  - Include timestamp in ISO 8601 format
- Implement log aggregation
  - Centralize logs for analysis
  - Use ELK stack or cloud service
  - Set up alerts for critical errors
- Never log sensitive data
  - Passwords, tokens, API keys
  - Credit card numbers
  - Personal identifiable information (PII)
  - Use masking utilities for necessary PII in logs
- Integrate error tracking (Sentry or similar)
  - Capture unhandled exceptions
  - Add context to errors (user, request, environment)
  - Set up alerts for critical errors
  - Track error trends and patterns
- Monitor performance
  - Track response times
  - Monitor database query performance
  - Set up alerts for slow endpoints
  - Use APM tools (New Relic, DataDog)

### Real-time Communication

- Use @nestjs/websockets with Socket.io
  - Create WebSocketGateway for real-time features
  - Use rooms for private chats
  - Implement proper namespaces for separation
- Implement WebSocket authentication
  - Use guards for WebSocket connections
  - Verify JWT tokens on connection
  - Handle token expiration gracefully
- Handle disconnections properly
  - Implement reconnection logic
  - Clean up resources on disconnect
  - Update user online status
- Emit typed events with DTOs
  - Define event interfaces
  - Validate event payloads
  - Document event types
- Implement rate limiting for WebSocket events
  - Prevent spam and abuse
  - Disconnect abusive clients
  - Log suspicious activity

### Background Jobs & Scheduling

- Use Bull/BullMQ for queue management
  - Create separate queues for different job types
  - Set appropriate concurrency limits
  - Implement job prioritization
- Use @nestjs/schedule for cron jobs
  - Document cron schedules clearly
  - Use timezone-aware scheduling
  - Implement idempotency for cron jobs
- Handle job failures with retry logic
  - Set maximum retry attempts
  - Use exponential backoff
  - Move to dead letter queue after max retries
  - Alert on repeated failures
- Log job execution
  - Log start and completion times
  - Log job results and errors
  - Track job performance metrics
- Common job types
  - Email notifications (async)
  - Push notifications (async)
  - Data cleanup (scheduled)
  - Report generation (scheduled)
  - Webhook retries (async with backoff)

### Content Moderation

- Implement automatic moderation for user-generated content
  - Block phone numbers in chat messages (regex patterns)
  - Block email addresses in chat messages
  - Block external links (except platform URLs)
  - Block social media handles (@instagram, @telegram, @whatsapp)
  - Filter profanity (Canadian English + French)
- Create moderation service with clear patterns
  - Use configurable regex patterns
  - Return moderation flags (phone, email, link, social)
  - Replace blocked content with *** or [removed]
  - Log moderation events for analytics
- Implement rate limiting for content creation
  - Limit messages per minute (20 per user)
  - Limit orders creation (10 per hour)
  - Limit profile updates (5 per hour)
- Create report/flag system
  - Allow users to report inappropriate content
  - Auto-suspend after threshold (e.g., 3 reports)
  - Queue for admin review
  - Track repeat offenders
- Moderate file uploads
  - AI-based NSFW detection for images
  - Manual review queue for suspicious content
  - Automatic approval for verified users
  - Track moderation decisions for appeals

### Payment Integration (Stripe)

- Never store credit card information
  - Use Stripe.js for card tokenization
  - Store only Stripe customer/payment method IDs
  - Comply with PCI DSS via Stripe
- Verify webhook signatures
  - Always verify Stripe webhook signatures
  - Use raw body for signature verification
  - Handle webhook events idempotently
  - Log all webhook events for debugging
- Use idempotency keys
  - Generate unique keys for payment operations
  - Prevent duplicate charges
  - Store keys with transaction records
- Implement 3D Secure (SCA)
  - Use PaymentIntents API
  - Handle authentication requirements
  - Provide clear user flow for verification
- Handle refunds properly
  - Implement refund policies
  - Track refund reasons
  - Update order status after refunds
  - Notify users of refund status
- Use Stripe metadata
  - Store order ID in Stripe metadata
  - Store user ID for tracking
  - Include platform-specific data
- Implement proper error handling
  - Handle card declined errors gracefully
  - Show user-friendly error messages
  - Log errors for debugging
  - Implement retry logic where appropriate

### Testing

- Use the standard Jest framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.
 