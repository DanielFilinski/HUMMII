---
alwaysApply: true
---

# Security & PIPEDA Compliance - Hummii

> **Security and PIPEDA compliance for Canadian market**
> **Version:** 1.0 | **Updated:** October 27, 2025

## PIPEDA Compliance (Canada)

**PIPEDA** (Personal Information Protection and Electronic Documents Act) - Canadian privacy law, similar to GDPR.

### Mandatory User Rights

#### 1. Right to Access
```typescript
// GET /api/v1/users/me/data
// Export all user data in JSON
{
  "profile": { /* user data */ },
  "orders": [ /* order history */ ],
  "messages": [ /* chat history (90 days) */ ],
  "reviews": [ /* ratings */ ],
  "payments": [ /* transaction history */ ]
}
```

#### 2. Right to Rectification
```typescript
// PATCH /api/v1/users/me
// User can update their data
```

#### 3. Right to Erasure
```typescript
// DELETE /api/v1/users/me
// Account deletion with:
// - Data anonymization in orders (for history)
// - PII deletion
// - Transaction records preserved (7 years - tax law)
```

#### 4. Right to Data Portability
```typescript
// GET /api/v1/users/me/export
// Export in machine-readable format (JSON)
```

### Data Minimization

**Collect only necessary data:**

```typescript
// ✅ GOOD - only needed fields
interface UserProfile {
  name: string;
  email: string;
  phone?: string; // Optional
}

// ❌ BAD - excessive data
interface UserProfile {
  name: string;
  email: string;
  age: number; // Not needed
  gender: string; // Not needed
  ssn: string; // NEVER collect unless absolutely required
}
```

### PII Masking in Logs

```typescript
// ❌ NEVER log:
// - Passwords
// - Tokens (access/refresh)
// - Credit cards
// - SIN (Social Insurance Number)
// - Full email/phone without masking

// ✅ CORRECT - masking
function maskEmail(email: string): string {
  const [user, domain] = email.split('@');
  return `${user.charAt(0)}${'*'.repeat(user.length - 1)}@${domain}`;
  // john.doe@example.com → j*******@example.com
}

function maskPhone(phone: string): string {
  return phone.replace(/\d(?=\d{4})/g, '*');
  // +1234567890 → ******7890
}

// Logging
logger.info('User login', {
  userId: user.id, // OK
  email: maskEmail(user.email), // Masked
  phone: maskPhone(user.phone), // Masked
  correlationId: req.correlationId, // OK
});
```

### Data Retention Policies

| Data Type | Retention Period | Justification |
|-----------|-----------------|---------------|
| **Chat messages** | 90 days | Business requirement |
| **Payment records** | 7 years | Canadian Tax Law (CRA requirement) |
| **User accounts** | Until deleted by user | User choice |
| **Audit logs** | 1 year minimum | Security & compliance |
| **Session data** | 7 days (refresh token) | Security |

## Authentication Security

### JWT Configuration

```typescript
// .env
JWT_ACCESS_SECRET=<256-bit random string>  // openssl rand -base64 64
JWT_REFRESH_SECRET=<256-bit random string>
JWT_ACCESS_EXPIRATION=15m    // Short-lived
JWT_REFRESH_EXPIRATION=7d    // Long-lived
```

### Token Storage

```typescript
// ✅ CORRECT - HTTP-only cookies (backend sets)
@Post('login')
async login(@Res({ passthrough: true }) res: Response) {
  const { accessToken, refreshToken } = await this.authService.login(dto);

  res.cookie('accessToken', accessToken, {
    httpOnly: true,        // Not accessible via JavaScript
    secure: true,          // HTTPS only
    sameSite: 'strict',    // CSRF protection
    maxAge: 15 * 60 * 1000, // 15 minutes
  });

  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  return { message: 'Login successful' };
}

// ❌ NEVER - localStorage/sessionStorage
// localStorage.setItem('token', accessToken); // Vulnerable to XSS!
```

### Password Security

```typescript
import * as bcrypt from 'bcrypt';

// ✅ Hashing with bcrypt (cost factor 12+)
const BCRYPT_ROUNDS = 12; // Higher = more secure but slower

async hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, BCRYPT_ROUNDS);
}

async verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// Password policy (validation)
const PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{12,}$/;
// Min 12 chars, 1 uppercase, 1 lowercase, 1 number, 1 special char
```

### Rate Limiting

```typescript
// Global rate limiting (@nestjs/throttler)
ThrottlerModule.forRoot({
  ttl: 60,      // Time window (seconds)
  limit: 100,   // Max requests per IP per window
}),

// Endpoint-specific limits
@Throttle(5, 60) // 5 requests per minute
@Post('login')
async login() { /* ... */ }

@Throttle(3, 60) // 3 requests per minute (stricter)
@Post('forgot-password')
async forgotPassword() { /* ... */ }

@Throttle(20, 60) // 20 messages per minute
@SubscribeMessage('sendMessage')
async handleMessage() { /* ... */ }
```

## Data Encryption

### Encryption at Rest

```typescript
// PostgreSQL - Transparent Data Encryption (TDE)
// Configure at database level (production)

// Field-level encryption for sensitive data
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY; // 256-bit key
const ALGORITHM = 'aes-256-cbc';

function encrypt(text: string): string {
  const iv = randomBytes(16);
  const cipher = createCipheriv(ALGORITHM, Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
  let encrypted = cipher.update(text);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return `${iv.toString('hex')}:${encrypted.toString('hex')}`;
}
```

### Encryption in Transit

```typescript
// HTTPS only - Nginx configuration
server {
  listen 443 ssl http2;
  ssl_protocols TLSv1.3 TLSv1.2;
  ssl_ciphers HIGH:!aNULL:!MD5;

  # HSTS
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
}

// Redirect HTTP to HTTPS
server {
  listen 80;
  return 301 https://$host$request_uri;
}
```

## Input Validation

### Backend Validation (class-validator)

```typescript
import { IsString, IsEmail, MinLength, MaxLength, Matches } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @MinLength(2)
  @MaxLength(100)
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(12)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])/, {
    message: 'Password too weak',
  })
  password: string;
}

// Global validation pipe (main.ts)
app.useGlobalPipes(new ValidationPipe({
  whitelist: true,              // Strip unknown properties
  forbidNonWhitelisted: true,   // Throw error on unknown properties
  transform: true,              // Auto type conversion
}));
```

### SQL Injection Prevention

```typescript
// ✅ CORRECT - Prisma ORM (parameterized queries)
const user = await prisma.user.findUnique({
  where: { email: userEmail },
});

// ❌ NEVER - String concatenation
const query = `SELECT * FROM users WHERE email = '${userEmail}'`; // SQL INJECTION!
```

## Payment Security (Stripe)

### Never Store Card Data

```typescript
// ❌ NEVER store:
// - Card numbers
// - CVV
// - Expiration dates

// ✅ CORRECT - use Stripe tokens
// Frontend: Stripe.js tokenizes card → backend receives token
const paymentMethod = await stripe.paymentMethods.create({
  type: 'card',
  card: { token: req.body.stripeToken }, // Token from Stripe.js
});

// Store only: Stripe customer ID, payment method ID
```

### Webhook Security

```typescript
@Post('webhook')
async handleStripeWebhook(
  @Req() req: RawBodyRequest<Request>,
  @Headers('stripe-signature') signature: string,
) {
  // ✅ ALWAYS verify signature
  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      req.rawBody,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET,
    );
  } catch (err) {
    throw new BadRequestException('Invalid signature');
  }

  // Handle event idempotently
  return { received: true };
}
```

## Content Moderation

### Automatic Filtering (Chat)

```typescript
export class ModerationService {
  moderateMessage(content: string): ModerationResult {
    const flags = {
      hasPhone: /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/.test(content),
      hasEmail: /\S+@\S+\.\S+/.test(content),
      hasUrl: /https?:\/\//.test(content),
      hasSocial: /@(instagram|telegram|whatsapp|facebook)/i.test(content),
      hasProfanity: this.checkProfanity(content),
    };

    const isAllowed = !Object.values(flags).some(Boolean);

    return {
      allowed: isAllowed,
      flags,
      cleaned: isAllowed ? content : this.cleanContent(content),
    };
  }
}
```

## Security Checklist

### Before Writing Code

- [ ] **User input** → Validate with class-validator (backend) + Zod (frontend)
- [ ] **Passwords** → Hash with bcrypt (cost 12+) or Argon2
- [ ] **Tokens** → HTTP-only cookies, NEVER localStorage
- [ ] **API keys** → Server-side only, NO `NEXT_PUBLIC_` prefix
- [ ] **Database queries** → Prisma ORM, NEVER string concatenation
- [ ] **File uploads** → Validate MIME type, strip EXIF, scan malware
- [ ] **Payments** → Stripe Elements, verify webhook signatures
- [ ] **PII** → Encrypt with AES-256, mask in logs
- [ ] **Errors** → Generic message for client, detailed log server-side
- [ ] **Rate limiting** → Apply to ALL endpoints (especially auth)

### Before Deploy to Production

- [ ] HTTPS enabled (TLS 1.3)
- [ ] Security headers (Helmet.js)
- [ ] CORS configured (whitelisted domains only)
- [ ] Rate limiting enabled
- [ ] Audit logging enabled
- [ ] Error tracking configured (Sentry)
- [ ] Database backups automated
- [ ] Secrets in environment variables (not code)
- [ ] PIPEDA compliance verified
- [ ] Security scan passed (Snyk, Trivy)

---

**Last updated:** October 27, 2025
**Priority:** CRITICAL
**Compliance:** PIPEDA (Canada)
